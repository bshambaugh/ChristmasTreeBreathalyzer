{"ast":null,"code":"export var validate=function validate(validator,source,options){return new Promise(function(resolve,reject){validator.validate(source,options?options:{},function(errors,fieldErrors){if(errors){reject(fieldErrors);}else{resolve(source);}});});};// eslint-disable-next-line max-len\nvar IP_ADDRESS_REGEXP=/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;var isValidIpAddress=function isValidIpAddress(value){return IP_ADDRESS_REGEXP.test(value);};export var IP_ADDRESS_VALIDATOR={validator:function validator(rule,value,callback){if(value&&!isValidIpAddress(value)){callback(\"Must be an IP address\");}else{callback();}}};var HOSTNAME_LENGTH_REGEXP=/^.{0,253}$/;var HOSTNAME_PATTERN_REGEXP=/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]))*$/;var isValidHostname=function isValidHostname(value){return HOSTNAME_LENGTH_REGEXP.test(value)&&HOSTNAME_PATTERN_REGEXP.test(value);};export var HOSTNAME_VALIDATOR={validator:function validator(rule,value,callback){if(value&&!isValidHostname(value)){callback(\"Must be a valid hostname of up to 253 characters\");}else{callback();}}};export var IP_OR_HOSTNAME_VALIDATOR={validator:function validator(rule,value,callback){if(value&&!(isValidIpAddress(value)||isValidHostname(value))){callback(\"Must be a valid IP address or hostname of up to 253 characters\");}else{callback();}}};","map":{"version":3,"sources":["/home/brent/Documents/PlatformIO/Projects/ESP32_C3_Test/interface/src/validators/shared.ts"],"names":["validate","validator","source","options","Promise","resolve","reject","errors","fieldErrors","IP_ADDRESS_REGEXP","isValidIpAddress","value","test","IP_ADDRESS_VALIDATOR","rule","callback","HOSTNAME_LENGTH_REGEXP","HOSTNAME_PATTERN_REGEXP","isValidHostname","HOSTNAME_VALIDATOR","IP_OR_HOSTNAME_VALIDATOR"],"mappings":"AAEA,MAAO,IAAMA,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAAmBC,SAAnB,CAAsCC,MAAtC,CAA0DC,OAA1D,CAAmG,CACzH,MAAO,IAAIC,CAAAA,OAAJ,CACL,SAACC,OAAD,CAAUC,MAAV,CAAqB,CACnBL,SAAS,CAACD,QAAV,CAAmBE,MAAnB,CAA2BC,OAAO,CAAGA,OAAH,CAAa,EAA/C,CAAmD,SAACI,MAAD,CAASC,WAAT,CAAyB,CAC1E,GAAID,MAAJ,CAAY,CACVD,MAAM,CAACE,WAAD,CAAN,CACD,CAFD,IAEO,CACLH,OAAO,CAACH,MAAD,CAAP,CACD,CACF,CAND,EAOD,CATI,CAAP,CAWD,CAZM,CAcP;AACA,GAAMO,CAAAA,iBAAiB,CAAG,kKAA1B,CACA,GAAMC,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACC,KAAD,QAAmBF,CAAAA,iBAAiB,CAACG,IAAlB,CAAuBD,KAAvB,CAAnB,EAAzB,CAEA,MAAO,IAAME,CAAAA,oBAAoB,CAAG,CAClCZ,SADkC,oBACxBa,IADwB,CACAH,KADA,CACeI,QADf,CACmD,CACnF,GAAIJ,KAAK,EAAI,CAACD,gBAAgB,CAACC,KAAD,CAA9B,CAAuC,CACrCI,QAAQ,CAAC,uBAAD,CAAR,CACD,CAFD,IAEO,CACLA,QAAQ,GACT,CACF,CAPiC,CAA7B,CAUP,GAAMC,CAAAA,sBAAsB,CAAG,YAA/B,CACA,GAAMC,CAAAA,uBAAuB,CAC3B,qHADF,CAGA,GAAMC,CAAAA,eAAe,CAAG,QAAlBA,CAAAA,eAAkB,CAACP,KAAD,QAAmBK,CAAAA,sBAAsB,CAACJ,IAAvB,CAA4BD,KAA5B,GAAsCM,uBAAuB,CAACL,IAAxB,CAA6BD,KAA7B,CAAzD,EAAxB,CAEA,MAAO,IAAMQ,CAAAA,kBAAkB,CAAG,CAChClB,SADgC,oBACtBa,IADsB,CACEH,KADF,CACiBI,QADjB,CACqD,CACnF,GAAIJ,KAAK,EAAI,CAACO,eAAe,CAACP,KAAD,CAA7B,CAAsC,CACpCI,QAAQ,CAAC,kDAAD,CAAR,CACD,CAFD,IAEO,CACLA,QAAQ,GACT,CACF,CAP+B,CAA3B,CAUP,MAAO,IAAMK,CAAAA,wBAAwB,CAAG,CACtCnB,SADsC,oBAC5Ba,IAD4B,CACJH,KADI,CACWI,QADX,CAC+C,CACnF,GAAIJ,KAAK,EAAI,EAAED,gBAAgB,CAACC,KAAD,CAAhB,EAA2BO,eAAe,CAACP,KAAD,CAA5C,CAAb,CAAmE,CACjEI,QAAQ,CAAC,gEAAD,CAAR,CACD,CAFD,IAEO,CACLA,QAAQ,GACT,CACF,CAPqC,CAAjC","sourcesContent":["import Schema, { InternalRuleItem, ValidateOption } from \"async-validator\";\n\nexport const validate = <T extends object>(validator: Schema, source: Partial<T>, options?: ValidateOption): Promise<T> => {\n  return new Promise(\n    (resolve, reject) => {\n      validator.validate(source, options ? options : {}, (errors, fieldErrors) => {\n        if (errors) {\n          reject(fieldErrors);\n        } else {\n          resolve(source as T);\n        }\n      });\n    }\n  );\n};\n\n// eslint-disable-next-line max-len\nconst IP_ADDRESS_REGEXP = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\nconst isValidIpAddress = (value: string) => IP_ADDRESS_REGEXP.test(value);\n\nexport const IP_ADDRESS_VALIDATOR = {\n  validator(rule: InternalRuleItem, value: string, callback: (error?: string) => void) {\n    if (value && !isValidIpAddress(value)) {\n      callback(\"Must be an IP address\");\n    } else {\n      callback();\n    }\n  }\n};\n\nconst HOSTNAME_LENGTH_REGEXP = /^.{0,253}$/;\nconst HOSTNAME_PATTERN_REGEXP =\n  /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]))*$/;\n\nconst isValidHostname = (value: string) => HOSTNAME_LENGTH_REGEXP.test(value) && HOSTNAME_PATTERN_REGEXP.test(value);\n\nexport const HOSTNAME_VALIDATOR = {\n  validator(rule: InternalRuleItem, value: string, callback: (error?: string) => void) {\n    if (value && !isValidHostname(value)) {\n      callback(\"Must be a valid hostname of up to 253 characters\");\n    } else {\n      callback();\n    }\n  }\n};\n\nexport const IP_OR_HOSTNAME_VALIDATOR = {\n  validator(rule: InternalRuleItem, value: string, callback: (error?: string) => void) {\n    if (value && !(isValidIpAddress(value) || isValidHostname(value))) {\n      callback(\"Must be a valid IP address or hostname of up to 253 characters\");\n    } else {\n      callback();\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}